// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -triple aarch64-arm-eabi -emit-llvm -w -emit-llvm -o - %s | FileCheck %s
// REQUIRES: arm-registered-target

// CHECK-LABEL: define dso_local float @f
// CHECK-SAME: (ptr noundef [[X:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[A:%.*]] = alloca float, align 4
// CHECK-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[A]], ptr align 1 [[TMP0]], i64 4, i1 false)
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[A]], align 4
// CHECK-NEXT:    ret float [[TMP1]]
//
float f(char* x) {
    float a;
    __builtin_memcpy(&a, x, sizeof(a));
    return a;
}

// CHECK-LABEL: define dso_local float @ff
// CHECK-SAME: (ptr noundef [[X:%.*]], float noundef [[F:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca float, align 4
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[F_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-NEXT:    store float [[F]], ptr [[F_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[TMP0]], ptr align 4 [[F_ADDR]], i64 4, i1 false)
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr [[RETVAL]], align 4
// CHECK-NEXT:    ret float [[TMP1]]
//
float ff(char* x, float f) {
    __builtin_memcpy(x, &f, sizeof(f));
}

// CHECK-LABEL: define dso_local double @d
// CHECK-SAME: (ptr noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[A]], ptr align 1 [[TMP0]], i64 8, i1 false)
// CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[A]], align 8
// CHECK-NEXT:    ret double [[TMP1]]
//
double d(char* x) {
    double a;
    __builtin_memcpy(&a, x, sizeof(a));
    return a;
}

// CHECK-LABEL: define dso_local double @dd
// CHECK-SAME: (ptr noundef [[X:%.*]], double noundef [[F:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca double, align 8
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[F_ADDR:%.*]] = alloca double, align 8
// CHECK-NEXT:    store ptr [[X]], ptr [[X_ADDR]], align 8
// CHECK-NEXT:    store double [[F]], ptr [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[X_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 1 [[TMP0]], ptr align 8 [[F_ADDR]], i64 8, i1 false)
// CHECK-NEXT:    [[TMP1:%.*]] = load double, ptr [[RETVAL]], align 8
// CHECK-NEXT:    ret double [[TMP1]]
//
double dd(char* x, double f) {
    __builtin_memcpy(x, &f, sizeof(f));
}
